{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Serialization_1 = require(\"../../Serialization\");\n\nconst Schema_1 = __importDefault(require(\"./Schema\"));\n\nclass RpcTemplate {\n  constructor(api, collection, id, data, schema, cache = true) {\n    this.api = api;\n    this.collection = collection;\n    this.id = id;\n    this._data = new Promise(async (resolve, reject) => {\n      if (data) {\n        resolve(data);\n      } else {\n        try {\n          resolve(await api.queue.fetchTemplate(collection, id, cache));\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n    this._schema = new Promise(async (resolve, reject) => {\n      if (schema) {\n        resolve(schema);\n      } else {\n        try {\n          const row = await this._data;\n          resolve(new Schema_1.default(this.api, collection, row.schema_name, undefined, cache));\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n  }\n\n  async schema() {\n    return await this._schema;\n  }\n\n  async immutableData() {\n    const schema = await this._schema;\n    return Serialization_1.deserialize((await this._data).immutable_serialized_data, await schema.format());\n  }\n\n  async isTransferable() {\n    return (await this._data).transferable;\n  }\n\n  async isBurnable() {\n    return (await this._data).burnable;\n  }\n\n  async maxSupply() {\n    return (await this._data).max_supply;\n  }\n\n  async circulation() {\n    return (await this._data).issued_supply;\n  }\n\n  async toObject() {\n    return {\n      collection_name: this.collection,\n      template_id: this.id,\n      schema: await (await this.schema()).toObject(),\n      immutableData: await this.immutableData(),\n      transferable: await this.isTransferable(),\n      burnable: await this.isBurnable(),\n      maxSupply: await this.maxSupply(),\n      circulation: await this.circulation()\n    };\n  }\n\n}\n\nexports.default = RpcTemplate;","map":{"version":3,"sources":["/Users/kevinbadinger/eos/reactdemo/WCWReact/node_modules/atomicassets/build/API/Rpc/Template.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Serialization_1","require","Schema_1","RpcTemplate","constructor","api","collection","id","data","schema","cache","_data","Promise","resolve","reject","queue","fetchTemplate","e","_schema","row","default","schema_name","undefined","immutableData","deserialize","immutable_serialized_data","format","isTransferable","transferable","isBurnable","burnable","maxSupply","max_supply","circulation","issued_supply","toObject","collection_name","template_id"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Serialization_1 = require(\"../../Serialization\");\nconst Schema_1 = __importDefault(require(\"./Schema\"));\nclass RpcTemplate {\n    constructor(api, collection, id, data, schema, cache = true) {\n        this.api = api;\n        this.collection = collection;\n        this.id = id;\n        this._data = new Promise(async (resolve, reject) => {\n            if (data) {\n                resolve(data);\n            }\n            else {\n                try {\n                    resolve(await api.queue.fetchTemplate(collection, id, cache));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n        });\n        this._schema = new Promise(async (resolve, reject) => {\n            if (schema) {\n                resolve(schema);\n            }\n            else {\n                try {\n                    const row = await this._data;\n                    resolve(new Schema_1.default(this.api, collection, row.schema_name, undefined, cache));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n        });\n    }\n    async schema() {\n        return await this._schema;\n    }\n    async immutableData() {\n        const schema = await this._schema;\n        return Serialization_1.deserialize((await this._data).immutable_serialized_data, await schema.format());\n    }\n    async isTransferable() {\n        return (await this._data).transferable;\n    }\n    async isBurnable() {\n        return (await this._data).burnable;\n    }\n    async maxSupply() {\n        return (await this._data).max_supply;\n    }\n    async circulation() {\n        return (await this._data).issued_supply;\n    }\n    async toObject() {\n        return {\n            collection_name: this.collection,\n            template_id: this.id,\n            schema: await (await this.schema()).toObject(),\n            immutableData: await this.immutableData(),\n            transferable: await this.isTransferable(),\n            burnable: await this.isBurnable(),\n            maxSupply: await this.maxSupply(),\n            circulation: await this.circulation()\n        };\n    }\n}\nexports.default = RpcTemplate;\n"]},"metadata":{},"sourceType":"script"}