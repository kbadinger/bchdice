{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/kevinbadinger/eos/reactdemo/WCWReact/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kevinbadinger/eos/reactdemo/WCWReact/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* based on npm base-x module (removed buffer, added class structure) */\n\nvar BaseCoder = /*#__PURE__*/function () {\n  function BaseCoder(ALPHABET) {\n    _classCallCheck(this, BaseCoder);\n\n    this.ALPHABET = ALPHABET;\n\n    if (ALPHABET.length >= 255) {\n      throw new TypeError('Alphabet too long');\n    }\n\n    this.BASE_MAP = new Uint8Array(256);\n\n    for (var j = 0; j < this.BASE_MAP.length; j++) {\n      this.BASE_MAP[j] = 255;\n    }\n\n    for (var i = 0; i < ALPHABET.length; i++) {\n      var x = ALPHABET.charAt(i);\n      var xc = x.charCodeAt(0);\n\n      if (this.BASE_MAP[xc] !== 255) {\n        throw new TypeError(x + ' is ambiguous');\n      }\n\n      this.BASE_MAP[xc] = i;\n    }\n\n    this.BASE = ALPHABET.length;\n    this.LEADER = ALPHABET.charAt(0);\n    this.FACTOR = Math.log(this.BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n\n    this.iFACTOR = Math.log(256) / Math.log(this.BASE); // log(256) / log(BASE), rounded up\n  }\n\n  _createClass(BaseCoder, [{\n    key: \"encode\",\n    value: function encode(source) {\n      if (source.length === 0) {\n        return '';\n      } // Skip & count leading zeroes.\n\n\n      var zeroes = 0;\n      var length = 0;\n      var pbegin = 0;\n      var pend = source.length;\n\n      while (pbegin !== pend && source[pbegin] === 0) {\n        pbegin++;\n        zeroes++;\n      } // Allocate enough space in big-endian base58 representation.\n\n\n      var size = (pend - pbegin) * this.iFACTOR + 1 >>> 0;\n      var b58 = new Uint8Array(size); // Process the bytes.\n\n      while (pbegin !== pend) {\n        var carry = source[pbegin]; // Apply \"b58 = b58 * 256 + ch\".\n\n        var i = 0;\n\n        for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n          carry += 256 * b58[it1] >>> 0;\n          b58[it1] = carry % this.BASE >>> 0;\n          carry = carry / this.BASE >>> 0;\n        }\n\n        if (carry !== 0) {\n          throw new Error('Non-zero carry');\n        }\n\n        length = i;\n        pbegin++;\n      } // Skip leading zeroes in base58 result.\n\n\n      var it2 = size - length;\n\n      while (it2 !== size && b58[it2] === 0) {\n        it2++;\n      } // Translate the result into a string.\n\n\n      var str = this.LEADER.repeat(zeroes);\n\n      for (; it2 < size; ++it2) {\n        str += this.ALPHABET.charAt(b58[it2]);\n      }\n\n      return str;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(source) {\n      var buffer = this.decodeUnsafe(source);\n\n      if (buffer) {\n        return buffer;\n      }\n\n      throw new Error('Non-base' + this.BASE + ' character');\n    }\n  }, {\n    key: \"decodeUnsafe\",\n    value: function decodeUnsafe(source) {\n      if (source.length === 0) {\n        return new Uint8Array(0);\n      }\n\n      var psz = 0; // Skip leading spaces.\n\n      if (source[psz] === ' ') {\n        return new Uint8Array(0);\n      } // Skip and count leading '1's.\n\n\n      var zeroes = 0;\n      var length = 0;\n\n      while (source[psz] === this.LEADER) {\n        zeroes++;\n        psz++;\n      } // Allocate enough space in big-endian base256 representation.\n\n\n      var size = (source.length - psz) * this.FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n\n      var b256 = new Uint8Array(size); // Process the characters.\n\n      while (source[psz]) {\n        // Decode character\n        var carry = this.BASE_MAP[source.charCodeAt(psz)]; // Invalid character\n\n        if (carry === 255) {\n          return new Uint8Array(0);\n        }\n\n        var i = 0;\n\n        for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n          carry += this.BASE * b256[it3] >>> 0;\n          b256[it3] = carry % 256 >>> 0;\n          carry = carry / 256 >>> 0;\n        }\n\n        if (carry !== 0) {\n          throw new Error('Non-zero carry');\n        }\n\n        length = i;\n        psz++;\n      } // Skip trailing spaces.\n\n\n      if (source[psz] === ' ') {\n        return new Uint8Array(0);\n      } // Skip leading zeroes in b256.\n\n\n      var it4 = size - length;\n\n      while (it4 !== size && b256[it4] === 0) {\n        it4++;\n      }\n\n      var vch = new Uint8Array(zeroes + (size - it4));\n      vch.fill(0x00, 0, zeroes);\n      var j = zeroes;\n\n      while (it4 !== size) {\n        vch[j++] = b256[it4++];\n      }\n\n      return vch;\n    }\n  }]);\n\n  return BaseCoder;\n}();\n\nexports.default = BaseCoder;","map":{"version":3,"sources":["/Users/kevinbadinger/eos/reactdemo/WCWReact/node_modules/atomicassets/build/Serialization/Coders/Base.js"],"names":["Object","defineProperty","exports","value","BaseCoder","ALPHABET","length","TypeError","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","source","zeroes","pbegin","pend","size","b58","carry","it1","Error","it2","str","repeat","buffer","decodeUnsafe","psz","b256","it3","it4","vch","fill","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* based on npm base-x module (removed buffer, added class structure) */\nclass BaseCoder {\n    constructor(ALPHABET) {\n        this.ALPHABET = ALPHABET;\n        if (ALPHABET.length >= 255) {\n            throw new TypeError('Alphabet too long');\n        }\n        this.BASE_MAP = new Uint8Array(256);\n        for (let j = 0; j < this.BASE_MAP.length; j++) {\n            this.BASE_MAP[j] = 255;\n        }\n        for (let i = 0; i < ALPHABET.length; i++) {\n            const x = ALPHABET.charAt(i);\n            const xc = x.charCodeAt(0);\n            if (this.BASE_MAP[xc] !== 255) {\n                throw new TypeError(x + ' is ambiguous');\n            }\n            this.BASE_MAP[xc] = i;\n        }\n        this.BASE = ALPHABET.length;\n        this.LEADER = ALPHABET.charAt(0);\n        this.FACTOR = Math.log(this.BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n        this.iFACTOR = Math.log(256) / Math.log(this.BASE); // log(256) / log(BASE), rounded up\n    }\n    encode(source) {\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        let zeroes = 0;\n        let length = 0;\n        let pbegin = 0;\n        const pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        const size = ((pend - pbegin) * this.iFACTOR + 1) >>> 0;\n        const b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            let carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            let i = 0;\n            for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % this.BASE) >>> 0;\n                carry = (carry / this.BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        let it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        let str = this.LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += this.ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    decode(source) {\n        const buffer = this.decodeUnsafe(source);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error('Non-base' + this.BASE + ' character');\n    }\n    decodeUnsafe(source) {\n        if (source.length === 0) {\n            return new Uint8Array(0);\n        }\n        let psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return new Uint8Array(0);\n        }\n        // Skip and count leading '1's.\n        let zeroes = 0;\n        let length = 0;\n        while (source[psz] === this.LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        const size = (((source.length - psz) * this.FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        const b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            let carry = this.BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return new Uint8Array(0);\n            }\n            let i = 0;\n            for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (this.BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return new Uint8Array(0);\n        }\n        // Skip leading zeroes in b256.\n        let it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        const vch = new Uint8Array(zeroes + (size - it4));\n        vch.fill(0x00, 0, zeroes);\n        let j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n}\nexports.default = BaseCoder;\n"]},"metadata":{},"sourceType":"script"}