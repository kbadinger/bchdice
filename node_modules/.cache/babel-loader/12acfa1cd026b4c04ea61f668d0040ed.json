{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* based on npm base-x module (removed buffer, added class structure) */\n\nclass BaseCoder {\n  constructor(ALPHABET) {\n    this.ALPHABET = ALPHABET;\n\n    if (ALPHABET.length >= 255) {\n      throw new TypeError('Alphabet too long');\n    }\n\n    this.BASE_MAP = new Uint8Array(256);\n\n    for (let j = 0; j < this.BASE_MAP.length; j++) {\n      this.BASE_MAP[j] = 255;\n    }\n\n    for (let i = 0; i < ALPHABET.length; i++) {\n      const x = ALPHABET.charAt(i);\n      const xc = x.charCodeAt(0);\n\n      if (this.BASE_MAP[xc] !== 255) {\n        throw new TypeError(x + ' is ambiguous');\n      }\n\n      this.BASE_MAP[xc] = i;\n    }\n\n    this.BASE = ALPHABET.length;\n    this.LEADER = ALPHABET.charAt(0);\n    this.FACTOR = Math.log(this.BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n\n    this.iFACTOR = Math.log(256) / Math.log(this.BASE); // log(256) / log(BASE), rounded up\n  }\n\n  encode(source) {\n    if (source.length === 0) {\n      return '';\n    } // Skip & count leading zeroes.\n\n\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    } // Allocate enough space in big-endian base58 representation.\n\n\n    const size = (pend - pbegin) * this.iFACTOR + 1 >>> 0;\n    const b58 = new Uint8Array(size); // Process the bytes.\n\n    while (pbegin !== pend) {\n      let carry = source[pbegin]; // Apply \"b58 = b58 * 256 + ch\".\n\n      let i = 0;\n\n      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % this.BASE >>> 0;\n        carry = carry / this.BASE >>> 0;\n      }\n\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n\n      length = i;\n      pbegin++;\n    } // Skip leading zeroes in base58 result.\n\n\n    let it2 = size - length;\n\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    } // Translate the result into a string.\n\n\n    let str = this.LEADER.repeat(zeroes);\n\n    for (; it2 < size; ++it2) {\n      str += this.ALPHABET.charAt(b58[it2]);\n    }\n\n    return str;\n  }\n\n  decode(source) {\n    const buffer = this.decodeUnsafe(source);\n\n    if (buffer) {\n      return buffer;\n    }\n\n    throw new Error('Non-base' + this.BASE + ' character');\n  }\n\n  decodeUnsafe(source) {\n    if (source.length === 0) {\n      return new Uint8Array(0);\n    }\n\n    let psz = 0; // Skip leading spaces.\n\n    if (source[psz] === ' ') {\n      return new Uint8Array(0);\n    } // Skip and count leading '1's.\n\n\n    let zeroes = 0;\n    let length = 0;\n\n    while (source[psz] === this.LEADER) {\n      zeroes++;\n      psz++;\n    } // Allocate enough space in big-endian base256 representation.\n\n\n    const size = (source.length - psz) * this.FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n\n    const b256 = new Uint8Array(size); // Process the characters.\n\n    while (source[psz]) {\n      // Decode character\n      let carry = this.BASE_MAP[source.charCodeAt(psz)]; // Invalid character\n\n      if (carry === 255) {\n        return new Uint8Array(0);\n      }\n\n      let i = 0;\n\n      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += this.BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n\n      length = i;\n      psz++;\n    } // Skip trailing spaces.\n\n\n    if (source[psz] === ' ') {\n      return new Uint8Array(0);\n    } // Skip leading zeroes in b256.\n\n\n    let it4 = size - length;\n\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n\n    const vch = new Uint8Array(zeroes + (size - it4));\n    vch.fill(0x00, 0, zeroes);\n    let j = zeroes;\n\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n\n    return vch;\n  }\n\n}\n\nexports.default = BaseCoder;","map":{"version":3,"sources":["/Users/kevinbadinger/eos/reactdemo/WCWReact/node_modules/atomicassets/build/Serialization/Coders/Base.js"],"names":["Object","defineProperty","exports","value","BaseCoder","constructor","ALPHABET","length","TypeError","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","encode","source","zeroes","pbegin","pend","size","b58","carry","it1","Error","it2","str","repeat","decode","buffer","decodeUnsafe","psz","b256","it3","it4","vch","fill","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;AACA,MAAMC,SAAN,CAAgB;AACZC,EAAAA,WAAW,CAACC,QAAD,EAAW;AAClB,SAAKA,QAAL,GAAgBA,QAAhB;;AACA,QAAIA,QAAQ,CAACC,MAAT,IAAmB,GAAvB,EAA4B;AACxB,YAAM,IAAIC,SAAJ,CAAc,mBAAd,CAAN;AACH;;AACD,SAAKC,QAAL,GAAgB,IAAIC,UAAJ,CAAe,GAAf,CAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKF,QAAL,CAAcF,MAAlC,EAA0CI,CAAC,EAA3C,EAA+C;AAC3C,WAAKF,QAAL,CAAcE,CAAd,IAAmB,GAAnB;AACH;;AACD,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAAQ,CAACC,MAA7B,EAAqCK,CAAC,EAAtC,EAA0C;AACtC,YAAMC,CAAC,GAAGP,QAAQ,CAACQ,MAAT,CAAgBF,CAAhB,CAAV;AACA,YAAMG,EAAE,GAAGF,CAAC,CAACG,UAAF,CAAa,CAAb,CAAX;;AACA,UAAI,KAAKP,QAAL,CAAcM,EAAd,MAAsB,GAA1B,EAA+B;AAC3B,cAAM,IAAIP,SAAJ,CAAcK,CAAC,GAAG,eAAlB,CAAN;AACH;;AACD,WAAKJ,QAAL,CAAcM,EAAd,IAAoBH,CAApB;AACH;;AACD,SAAKK,IAAL,GAAYX,QAAQ,CAACC,MAArB;AACA,SAAKW,MAAL,GAAcZ,QAAQ,CAACQ,MAAT,CAAgB,CAAhB,CAAd;AACA,SAAKK,MAAL,GAAcC,IAAI,CAACC,GAAL,CAAS,KAAKJ,IAAd,IAAsBG,IAAI,CAACC,GAAL,CAAS,GAAT,CAApC,CAnBkB,CAmBiC;;AACnD,SAAKC,OAAL,GAAeF,IAAI,CAACC,GAAL,CAAS,GAAT,IAAgBD,IAAI,CAACC,GAAL,CAAS,KAAKJ,IAAd,CAA/B,CApBkB,CAoBkC;AACvD;;AACDM,EAAAA,MAAM,CAACC,MAAD,EAAS;AACX,QAAIA,MAAM,CAACjB,MAAP,KAAkB,CAAtB,EAAyB;AACrB,aAAO,EAAP;AACH,KAHU,CAIX;;;AACA,QAAIkB,MAAM,GAAG,CAAb;AACA,QAAIlB,MAAM,GAAG,CAAb;AACA,QAAImB,MAAM,GAAG,CAAb;AACA,UAAMC,IAAI,GAAGH,MAAM,CAACjB,MAApB;;AACA,WAAOmB,MAAM,KAAKC,IAAX,IAAmBH,MAAM,CAACE,MAAD,CAAN,KAAmB,CAA7C,EAAgD;AAC5CA,MAAAA,MAAM;AACND,MAAAA,MAAM;AACT,KAZU,CAaX;;;AACA,UAAMG,IAAI,GAAI,CAACD,IAAI,GAAGD,MAAR,IAAkB,KAAKJ,OAAvB,GAAiC,CAAlC,KAAyC,CAAtD;AACA,UAAMO,GAAG,GAAG,IAAInB,UAAJ,CAAekB,IAAf,CAAZ,CAfW,CAgBX;;AACA,WAAOF,MAAM,KAAKC,IAAlB,EAAwB;AACpB,UAAIG,KAAK,GAAGN,MAAM,CAACE,MAAD,CAAlB,CADoB,CAEpB;;AACA,UAAId,CAAC,GAAG,CAAR;;AACA,WAAK,IAAImB,GAAG,GAAGH,IAAI,GAAG,CAAtB,EAAyB,CAACE,KAAK,KAAK,CAAV,IAAelB,CAAC,GAAGL,MAApB,KAAgCwB,GAAG,KAAK,CAAC,CAAlE,EAAsEA,GAAG,IAAInB,CAAC,EAA9E,EAAkF;AAC9EkB,QAAAA,KAAK,IAAK,MAAMD,GAAG,CAACE,GAAD,CAAV,KAAqB,CAA9B;AACAF,QAAAA,GAAG,CAACE,GAAD,CAAH,GAAYD,KAAK,GAAG,KAAKb,IAAd,KAAwB,CAAnC;AACAa,QAAAA,KAAK,GAAIA,KAAK,GAAG,KAAKb,IAAd,KAAwB,CAAhC;AACH;;AACD,UAAIa,KAAK,KAAK,CAAd,EAAiB;AACb,cAAM,IAAIE,KAAJ,CAAU,gBAAV,CAAN;AACH;;AACDzB,MAAAA,MAAM,GAAGK,CAAT;AACAc,MAAAA,MAAM;AACT,KA/BU,CAgCX;;;AACA,QAAIO,GAAG,GAAGL,IAAI,GAAGrB,MAAjB;;AACA,WAAO0B,GAAG,KAAKL,IAAR,IAAgBC,GAAG,CAACI,GAAD,CAAH,KAAa,CAApC,EAAuC;AACnCA,MAAAA,GAAG;AACN,KApCU,CAqCX;;;AACA,QAAIC,GAAG,GAAG,KAAKhB,MAAL,CAAYiB,MAAZ,CAAmBV,MAAnB,CAAV;;AACA,WAAOQ,GAAG,GAAGL,IAAb,EAAmB,EAAEK,GAArB,EAA0B;AACtBC,MAAAA,GAAG,IAAI,KAAK5B,QAAL,CAAcQ,MAAd,CAAqBe,GAAG,CAACI,GAAD,CAAxB,CAAP;AACH;;AACD,WAAOC,GAAP;AACH;;AACDE,EAAAA,MAAM,CAACZ,MAAD,EAAS;AACX,UAAMa,MAAM,GAAG,KAAKC,YAAL,CAAkBd,MAAlB,CAAf;;AACA,QAAIa,MAAJ,EAAY;AACR,aAAOA,MAAP;AACH;;AACD,UAAM,IAAIL,KAAJ,CAAU,aAAa,KAAKf,IAAlB,GAAyB,YAAnC,CAAN;AACH;;AACDqB,EAAAA,YAAY,CAACd,MAAD,EAAS;AACjB,QAAIA,MAAM,CAACjB,MAAP,KAAkB,CAAtB,EAAyB;AACrB,aAAO,IAAIG,UAAJ,CAAe,CAAf,CAAP;AACH;;AACD,QAAI6B,GAAG,GAAG,CAAV,CAJiB,CAKjB;;AACA,QAAIf,MAAM,CAACe,GAAD,CAAN,KAAgB,GAApB,EAAyB;AACrB,aAAO,IAAI7B,UAAJ,CAAe,CAAf,CAAP;AACH,KARgB,CASjB;;;AACA,QAAIe,MAAM,GAAG,CAAb;AACA,QAAIlB,MAAM,GAAG,CAAb;;AACA,WAAOiB,MAAM,CAACe,GAAD,CAAN,KAAgB,KAAKrB,MAA5B,EAAoC;AAChCO,MAAAA,MAAM;AACNc,MAAAA,GAAG;AACN,KAfgB,CAgBjB;;;AACA,UAAMX,IAAI,GAAK,CAACJ,MAAM,CAACjB,MAAP,GAAgBgC,GAAjB,IAAwB,KAAKpB,MAA9B,GAAwC,CAAzC,KAAgD,CAA7D,CAjBiB,CAiB+C;;AAChE,UAAMqB,IAAI,GAAG,IAAI9B,UAAJ,CAAekB,IAAf,CAAb,CAlBiB,CAmBjB;;AACA,WAAOJ,MAAM,CAACe,GAAD,CAAb,EAAoB;AAChB;AACA,UAAIT,KAAK,GAAG,KAAKrB,QAAL,CAAce,MAAM,CAACR,UAAP,CAAkBuB,GAAlB,CAAd,CAAZ,CAFgB,CAGhB;;AACA,UAAIT,KAAK,KAAK,GAAd,EAAmB;AACf,eAAO,IAAIpB,UAAJ,CAAe,CAAf,CAAP;AACH;;AACD,UAAIE,CAAC,GAAG,CAAR;;AACA,WAAK,IAAI6B,GAAG,GAAGb,IAAI,GAAG,CAAtB,EAAyB,CAACE,KAAK,KAAK,CAAV,IAAelB,CAAC,GAAGL,MAApB,KAAgCkC,GAAG,KAAK,CAAC,CAAlE,EAAsEA,GAAG,IAAI7B,CAAC,EAA9E,EAAkF;AAC9EkB,QAAAA,KAAK,IAAK,KAAKb,IAAL,GAAYuB,IAAI,CAACC,GAAD,CAAjB,KAA4B,CAArC;AACAD,QAAAA,IAAI,CAACC,GAAD,CAAJ,GAAaX,KAAK,GAAG,GAAT,KAAkB,CAA9B;AACAA,QAAAA,KAAK,GAAIA,KAAK,GAAG,GAAT,KAAkB,CAA1B;AACH;;AACD,UAAIA,KAAK,KAAK,CAAd,EAAiB;AACb,cAAM,IAAIE,KAAJ,CAAU,gBAAV,CAAN;AACH;;AACDzB,MAAAA,MAAM,GAAGK,CAAT;AACA2B,MAAAA,GAAG;AACN,KAtCgB,CAuCjB;;;AACA,QAAIf,MAAM,CAACe,GAAD,CAAN,KAAgB,GAApB,EAAyB;AACrB,aAAO,IAAI7B,UAAJ,CAAe,CAAf,CAAP;AACH,KA1CgB,CA2CjB;;;AACA,QAAIgC,GAAG,GAAGd,IAAI,GAAGrB,MAAjB;;AACA,WAAOmC,GAAG,KAAKd,IAAR,IAAgBY,IAAI,CAACE,GAAD,CAAJ,KAAc,CAArC,EAAwC;AACpCA,MAAAA,GAAG;AACN;;AACD,UAAMC,GAAG,GAAG,IAAIjC,UAAJ,CAAee,MAAM,IAAIG,IAAI,GAAGc,GAAX,CAArB,CAAZ;AACAC,IAAAA,GAAG,CAACC,IAAJ,CAAS,IAAT,EAAe,CAAf,EAAkBnB,MAAlB;AACA,QAAId,CAAC,GAAGc,MAAR;;AACA,WAAOiB,GAAG,KAAKd,IAAf,EAAqB;AACjBe,MAAAA,GAAG,CAAChC,CAAC,EAAF,CAAH,GAAW6B,IAAI,CAACE,GAAG,EAAJ,CAAf;AACH;;AACD,WAAOC,GAAP;AACH;;AAjIW;;AAmIhBzC,OAAO,CAAC2C,OAAR,GAAkBzC,SAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* based on npm base-x module (removed buffer, added class structure) */\nclass BaseCoder {\n    constructor(ALPHABET) {\n        this.ALPHABET = ALPHABET;\n        if (ALPHABET.length >= 255) {\n            throw new TypeError('Alphabet too long');\n        }\n        this.BASE_MAP = new Uint8Array(256);\n        for (let j = 0; j < this.BASE_MAP.length; j++) {\n            this.BASE_MAP[j] = 255;\n        }\n        for (let i = 0; i < ALPHABET.length; i++) {\n            const x = ALPHABET.charAt(i);\n            const xc = x.charCodeAt(0);\n            if (this.BASE_MAP[xc] !== 255) {\n                throw new TypeError(x + ' is ambiguous');\n            }\n            this.BASE_MAP[xc] = i;\n        }\n        this.BASE = ALPHABET.length;\n        this.LEADER = ALPHABET.charAt(0);\n        this.FACTOR = Math.log(this.BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n        this.iFACTOR = Math.log(256) / Math.log(this.BASE); // log(256) / log(BASE), rounded up\n    }\n    encode(source) {\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        let zeroes = 0;\n        let length = 0;\n        let pbegin = 0;\n        const pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        const size = ((pend - pbegin) * this.iFACTOR + 1) >>> 0;\n        const b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            let carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            let i = 0;\n            for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % this.BASE) >>> 0;\n                carry = (carry / this.BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        let it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        let str = this.LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += this.ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    decode(source) {\n        const buffer = this.decodeUnsafe(source);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error('Non-base' + this.BASE + ' character');\n    }\n    decodeUnsafe(source) {\n        if (source.length === 0) {\n            return new Uint8Array(0);\n        }\n        let psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return new Uint8Array(0);\n        }\n        // Skip and count leading '1's.\n        let zeroes = 0;\n        let length = 0;\n        while (source[psz] === this.LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        const size = (((source.length - psz) * this.FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        const b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            let carry = this.BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return new Uint8Array(0);\n            }\n            let i = 0;\n            for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (this.BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return new Uint8Array(0);\n        }\n        // Skip leading zeroes in b256.\n        let it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        const vch = new Uint8Array(zeroes + (size - it4));\n        vch.fill(0x00, 0, zeroes);\n        let j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n}\nexports.default = BaseCoder;\n"]},"metadata":{},"sourceType":"script"}