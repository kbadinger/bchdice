{"ast":null,"code":"/**\n * pure javascript functions to read and write 32-bit and 64-bit IEEE 754 floating-point\n *\n * Copyright (C) 2017-2019 Andras Radics\n * Licensed under the Apache License, Version 2.0\n */\n// removed buffer\n'use strict';\n\nvar isBigeCpu = false;\nvar readFloat32Array, writeFloat32Array, readFloat32ArrayRev, writeFloat32ArrayRev;\nvar readFloat64Array, writeFloat64Array, readFloat64ArrayRev, writeFloat64ArrayRev; // test FloatArray existence with && to not throw off code coverage\n\ntypeof Float32Array === 'function' && function () {\n  var _fp32 = new Float32Array(1);\n\n  var _b32 = new Uint8Array(_fp32.buffer);\n\n  _fp32[0] = -1;\n  isBigeCpu = _b32[3] === 0;\n\n  readFloat32Array = function readFloat32Array(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 4 > buf.length) return 0;\n    _b32[0] = buf[pos++];\n    _b32[1] = buf[pos++];\n    _b32[2] = buf[pos++];\n    _b32[3] = buf[pos]; //_b32[0] = buf[pos+0]; _b32[1] = buf[pos+1]; _b32[2] = buf[pos+2]; _b32[3] = buf[pos+3];\n\n    return _fp32[0];\n  };\n\n  readFloat32ArrayRev = function readFloat32ArrayRev(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 4 > buf.length) return 0;\n    _b32[3] = buf[pos++];\n    _b32[2] = buf[pos++];\n    _b32[1] = buf[pos++];\n    _b32[0] = buf[pos]; //_b32[3] = buf[pos+0]; _b32[2] = buf[pos+1]; _b32[1] = buf[pos+2]; _b32[0] = buf[pos+3];\n\n    return _fp32[0];\n  };\n\n  writeFloat32Array = function writeFloat32Array(buf, v, pos) {\n    pos = pos || 0;\n    _fp32[0] = v;\n    buf[pos++] = _b32[0];\n    buf[pos++] = _b32[1];\n    buf[pos++] = _b32[2];\n    buf[pos] = _b32[3]; //buf[pos+0] = _b32[0]; buf[pos+1] = _b32[1]; buf[pos+2] = _b32[2]; buf[pos+3] = _b32[3];\n  };\n\n  writeFloat32ArrayRev = function writeFloat32ArrayRev(buf, v, pos) {\n    pos = pos || 0;\n    _fp32[0] = v;\n    buf[pos++] = _b32[3];\n    buf[pos++] = _b32[2];\n    buf[pos++] = _b32[1];\n    buf[pos] = _b32[0]; //buf[pos+0] = _b32[3]; buf[pos+1] = _b32[2]; buf[pos+2] = _b32[1]; buf[pos+3] = _b32[0];\n  };\n}();\ntypeof Float64Array === 'function' && function () {\n  var _fp64 = new Float64Array(1);\n\n  var _b64 = new Uint8Array(_fp64.buffer);\n\n  readFloat64Array = function readFloat64Array(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 8 > buf.length) return 0; //_b64[0] = buf[pos++]; _b64[1] = buf[pos++]; _b64[2] = buf[pos++]; _b64[3] = buf[pos++];\n    //_b64[4] = buf[pos++]; _b64[5] = buf[pos++]; _b64[6] = buf[pos++]; _b64[7] = buf[pos];\n\n    _b64[0] = buf[pos + 0];\n    _b64[1] = buf[pos + 1];\n    _b64[2] = buf[pos + 2];\n    _b64[3] = buf[pos + 3];\n    _b64[4] = buf[pos + 4];\n    _b64[5] = buf[pos + 5];\n    _b64[6] = buf[pos + 6];\n    _b64[7] = buf[pos + 7];\n    return _fp64[0];\n  };\n\n  readFloat64ArrayRev = function readFloat64ArrayRev(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 8 > buf.length) return 0; //_b64[7] = buf[pos++]; _b64[6] = buf[pos++]; _b64[5] = buf[pos++]; _b64[4] = buf[pos++];\n    //_b64[3] = buf[pos++]; _b64[2] = buf[pos++]; _b64[1] = buf[pos++]; _b64[0] = buf[pos];\n\n    _b64[7] = buf[pos + 0];\n    _b64[6] = buf[pos + 1];\n    _b64[5] = buf[pos + 2];\n    _b64[4] = buf[pos + 3];\n    _b64[3] = buf[pos + 4];\n    _b64[2] = buf[pos + 5];\n    _b64[1] = buf[pos + 6];\n    _b64[0] = buf[pos + 7];\n    return _fp64[0];\n  };\n\n  writeFloat64Array = function writeFloat64Array(buf, v, pos) {\n    pos = pos || 0;\n    _fp64[0] = v;\n    buf[pos + 0] = _b64[0];\n    buf[pos + 1] = _b64[1];\n    buf[pos + 2] = _b64[2];\n    buf[pos + 3] = _b64[3];\n    buf[pos + 4] = _b64[4];\n    buf[pos + 5] = _b64[5];\n    buf[pos + 6] = _b64[6];\n    buf[pos + 7] = _b64[7];\n  };\n\n  writeFloat64ArrayRev = function writeFloat64ArrayRev(buf, v, pos) {\n    pos = pos || 0;\n    _fp64[0] = v;\n    buf[pos + 0] = _b64[7];\n    buf[pos + 1] = _b64[6];\n    buf[pos + 2] = _b64[5];\n    buf[pos + 3] = _b64[4];\n    buf[pos + 4] = _b64[3];\n    buf[pos + 5] = _b64[2];\n    buf[pos + 6] = _b64[1];\n    buf[pos + 7] = _b64[0];\n  };\n}(); // arithmetic operations preserve NaN, but logical ops (, >>, etc) convert them to zero\n// Assemble the word to generate NaN if any reads are undefined (outside the bounds of the array).\n\nfunction readWord(buf, offs, dirn) {\n  var a = buf[offs++],\n      b = buf[offs++],\n      c = buf[offs++],\n      d = buf[offs];\n  return dirn === 'bige' ? ((a * 256 + b) * 256 + c) * 256 + d : ((d * 256 + c) * 256 + b) * 256 + a;\n}\n\nfunction writeWord(buf, v, offs, dirn) {\n  var a = v >>> 24 & 0xff,\n      b = v >> 16 & 0xff,\n      c = v >> 8 & 0xff,\n      d = v & 0xff;\n  dirn === 'bige' ? (buf[offs++] = a, buf[offs++] = b, buf[offs++] = c, buf[offs] = d) : (buf[offs++] = d, buf[offs++] = c, buf[offs++] = b, buf[offs] = a);\n} // write the two-word value [hi,lo] where hi holds the 32 msb bits and lo the 32 lsb bits\n\n\nfunction writeDoubleWord(buf, hi, lo, offs, dirn) {\n  if (dirn === 'bige') {\n    writeWord(buf, hi, offs, dirn);\n    writeWord(buf, lo, offs + 4, dirn);\n  } else {\n    writeWord(buf, lo, offs, dirn);\n    writeWord(buf, hi, offs + 4, dirn);\n  }\n} // given an exponent n, return 2**n\n// n is always an integer, faster to shift when possible\n// Note that nodejs Math.pow() is faster than a lookup table (may be caching)\n\n\nvar _2eXp = new Array();\n\nfor (var i = 0; i < 1200; i++) _2eXp[i] = Math.pow(2, i);\n\nvar _2eXn = new Array();\n\nfor (var i = 0; i < 1200; i++) _2eXn[i] = Math.pow(2, -i);\n\nfunction pow2(exp) {\n  return exp >= 0 ? _2eXp[exp] : _2eXn[-exp]; //return (exp >= 0) ? (exp <  31 ? (1 << exp) :        Math.pow(2, exp))\n  //                  : (exp > -31 ? (1 / (1 << -exp)) : Math.pow(2, exp));\n} // getFloat() from qbson, https://github.com/andrasq/node-qbson:\n\n/*\n * extract the 64-bit little-endian ieee 754 floating-point value\n *   see http://en.wikipedia.org/wiki/Double-precision_floating-point_format\n *   1 bit sign + 11 bits exponent + (1 implicit mantissa 1 bit) + 52 mantissa bits\n */\n\n\nvar _rshift32 = 1 / 0x100000000; // >> 32 for floats\n\n\nvar _rshift20 = 1 / 0x100000; // >> 20 for floats\n\n\nvar _lshift32 = 1 * 0x100000000; // << 32\n\n\nvar _rshift52 = 1 * _rshift32 * _rshift20; // >> 52\n\n\nvar _rshift1023 = pow2(-1023); // 2^-1023\n\n\nfunction readDouble(buf, offset, dirn) {\n  var w0 = readWord(buf, offset, dirn);\n  var w1 = readWord(buf, offset + 4, dirn);\n  var highWord, lowWord;\n  dirn === 'bige' ? (highWord = w0, lowWord = w1) : (highWord = w1, lowWord = w0);\n  var mantissa = (highWord & 0x000FFFFF) * _lshift32 + lowWord;\n  var exponent = (highWord & 0x7FF00000) >>> 20;\n  var sign = highWord >> 31 || 1; // -1, 1, or 1 if NaN\n\n  var value;\n\n  if (exponent === 0x000) {\n    // zero if !mantissa, else subnormal (non-normalized reduced precision small value)\n    // recover negative zero -0.0 as distinct from 0.0\n    // subnormals do not have an implied leading 1 bit and are positioned 1 bit to the left\n    value = mantissa ? mantissa * pow2(-52 + 1 - 1023) : 0.0;\n  } else if (exponent < 0x7ff) {\n    // normalized value with an implied leading 1 bit and 1023 biased exponent\n    // test for NaN with (mantissa >= 0), and return 0 if NaN ie read from outside buffer bounds\n    value = mantissa >= 0 ? (1 + mantissa * _rshift52) * pow2(exponent - 1023) : 0.0;\n  } else {\n    // Infinity if zero mantissa (+/- per sign), NaN if nonzero mantissa\n    value = mantissa ? NaN : Infinity;\n  }\n\n  return sign * value;\n} //\n// Note: node-v9 prefers +28% (sign * value), node v6 doesnt care, node v8 likes +16% (-value : value)\n//\n// float32: 1 sign + 8 exponent + 24 mantissa (23 stored, 1 implied)\n// see https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n//\n// Exponent     Mantissa == 0   Mantissa > 0    Value\n// 00           +0, -0          denormalized    2^(  1-127) * (0. + (mantissa / 2^23))\n// 00.. FE                      normalized      2^(exp-127) * (1. + (mantissa / 2^23))\n// FF           +/-Infinity     NaN             -\n//\n\n\nvar _rshift23 = Math.pow(2, -23); // >> 23 for floats\n\n\nvar _rshift127 = Math.pow(2, -127); // 2^-127\n\n\nfunction readFloat(buf, offset, dirn) {\n  var word = readWord(buf, offset, dirn);\n  var mantissa = word & 0x007FFFFF;\n  var exponent = (word & 0x7F800000) >>> 23;\n  var sign = word >> 31 || 1; // -1, 1, or 1 if NaN\n\n  var value;\n\n  if (exponent === 0x000) {\n    value = mantissa ? mantissa * _rshift23 * 2 * _rshift127 : 0.0;\n  } else if (exponent < 0xff) {\n    value = (1 + mantissa * _rshift23) * pow2(exponent - 127); // * _rshift127;\n  } else {\n    value = mantissa ? NaN : Infinity;\n  }\n\n  return sign * value; //return (word >>> 31) ? -value : value;\n} // given a positive value v, normalize it to between 1 and less than 2 with a binary exponent\n// The exponent is the number of bit places it was shifted, positive if v was >= 2.\n// The special values 0, -0, NaN, +Infinity and -Infinity are not handled here.\n// Looping is faster than (Math.log(v) / Math.LN2) in node-v6, v8, and v9.\n// This function can account for half the time taken to write a double.\n\n\nvar _parts = {\n  exp: 0,\n  mant: 0\n};\n\nfunction normalize(v) {\n  var exp = 0;\n\n  if (v >= 2) {\n    exp = countDoublings(1, v);\n    v *= pow2(-exp); // if doubled to exactly v/2, adjust up to v\n\n    if (v >= 2) {\n      v /= 2;\n      exp += 1;\n    }\n  } else if (v < 1) {\n    exp = countDoublings(v, 2); // avoid using pow2 exponents > 1023, they overflow to Infinity\n\n    if (exp <= 1023) v *= pow2(exp);else {\n      v *= pow2(exp - 100);\n      v *= pow2(100);\n    }\n    exp = -exp;\n  } // TODO: pass in num bits, and normalize straight to mantissa / denorm\n\n\n  _parts.exp = exp;\n  _parts.mant = v;\n  return _parts;\n} // count how many doublings of a are needed for it be close to b.\n// Returns a shift count that grows (a) to at least (b/2) but less than (b).\n// Doubling 1 toward v ensures that (v >> n) >= 1 < 2,\n// and doubling from v toward 2 ensures that (v << n) >= 1 < 2.\n\n\nvar _2e192 = Math.pow(2, 192);\n\nfunction countDoublings(a, b) {\n  var n = 0;\n\n  while (a * _2e192 < b) {\n    a *= _2e192;\n    n += 192;\n  }\n\n  while (a * 0x10000000000000000 < b) {\n    a *= 0x10000000000000000;\n    n += 64;\n  }\n\n  while (a * 0x10000 < b) {\n    a *= 0x10000;\n    n += 16;\n  }\n\n  while (a * 0x40 < b) {\n    a *= 0x40;\n    n += 6;\n  }\n\n  while (a * 2 < b) {\n    a *= 2;\n    n += 1;\n  }\n\n  return n;\n} // round the fraction in v and scale up to scale = 2^n bits\n// https://blog.angularindepth.com/how-to-round-binary-fractions-625c8fa3a1af\n// Rounding can cause the scaled value to exceed 2^n.\n\n\nfunction roundMantissa(v, scale) {\n  v *= scale; // round to nearest, but round a 0.5 tie to even (0.5 to 0.0 and 1.5 to 2.0)\n  // round all numbers with a fraction other than 1/2, and round up odd numbers with\n\n  return v - Math.floor(v) !== 0.5 || v & 1 ? v + 0.5 : v;\n} // float32: 1 sign + 8 exponent + (1 implied mantissa 1 bit) + 23 stored mantissa bits\n// NaN types: quiet Nan = x.ff.8xxx, signaling NaN = x.ff.0xx1 (msb zero, at least one other bit set)\n// JavaScript built-in NaN is the non-signaling 7fc00000, but arithmetic can yield a negative NaN ffc00000.\n\n\nfunction writeFloat(buf, v, offset, dirn) {\n  var norm,\n      word,\n      sign = 0;\n\n  if (v < 0) {\n    sign = 0x80000000;\n    v = -v;\n  }\n\n  if (!(v && v < Infinity)) {\n    if (v === 0) {\n      // -0, +0\n      word = 1 / v < 0 ? 0x80000000 : 0x00000000;\n    } else if (v === Infinity) {\n      // -Infinity, +Infinity\n      word = sign | 0x7F800000;\n    } else {\n      // NaN - positive, non-signaling\n      word = 0x7FC00000;\n    }\n\n    writeWord(buf, word, offset, dirn);\n  } else {\n    norm = normalize(v); // separate exponent and mantissa\n\n    norm.exp += 127; // bias exponent\n\n    if (norm.exp <= 0) {\n      // denormalized number\n      if (norm.exp <= -25) {\n        // too small, underflow to zero.  -24 might round up though.\n        norm.mant = 0;\n        norm.exp = 0;\n      } else {\n        // denormalize\n        norm.mant = roundMantissa(norm.mant, pow2(22 + norm.exp));\n        norm.exp = 0; // rounding can carry out and re-normalize the number\n\n        if (norm.mant >= 0x800000) {\n          norm.mant -= 0x800000;\n          norm.exp += 1;\n        }\n      }\n    } else {\n      norm.mant = roundMantissa(norm.mant - 1, 0x800000); // if rounding overflowed into the hidden 1s place, hide it and adjust the exponent\n\n      if (norm.mant >= 0x800000) {\n        norm.mant -= 0x800000;\n        norm.exp += 1;\n      }\n\n      if (norm.exp > 254) {\n        // overflow to Infinity\n        norm.mant = 0;\n        norm.exp = 255;\n      }\n    }\n\n    word = sign | norm.exp << 23 | norm.mant;\n    writeWord(buf, word, offset, dirn);\n  }\n} // double64: 1 bit sign + 11 bits exponent + (1 implied mantissa 1 bit) + 52 stored mantissa bits\n// Writing doubles is simpler than floats, because the internal javascript 64-bit floats\n// are identical to the stored representation, and thus will not overflow or underflow.\n\n\nvar doubleArray = [0, 0, 0, 0, 0, 0, 0, 0];\nvar doubleBuf = new Uint8Array(8);\n\nvar _2e52 = Math.pow(2, 52);\n\nfunction writeDouble(buf, v, offset, dirn) {\n  var norm,\n      highWord,\n      lowWord,\n      sign = 0;\n\n  if (v < 0) {\n    sign = 0x80000000;\n    v = -v;\n  }\n\n  if (!(v && v < Infinity)) {\n    if (v === 0) {\n      // -0, +0\n      highWord = 1 / v < 0 ? 0x80000000 : 0;\n      lowWord = 0;\n    } else if (v === Infinity) {\n      // -Infinity, +Infinity\n      highWord = sign + 0x7FF00000;\n      lowWord = 0;\n    } else {\n      // NaN - positive, non-signaling\n      highWord = 0x7FF80000;\n      lowWord = 0;\n    }\n\n    writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n  } else {\n    norm = normalize(v); // separate exponent and mantissa\n\n    norm.exp += 1023; // bias exponent\n\n    if (norm.exp <= 0) {\n      // denormalized\n      // JavaScript numbers can not hold values small enough to underflow\n      // and no need to round, all bits will be written\n      norm.mant *= pow2(51 + norm.exp);\n      norm.exp = 0;\n    } else {\n      // no need to round, all bits will be written\n      norm.mant = (norm.mant - 1) * _2e52;\n    }\n\n    highWord = sign | norm.exp << 20 | norm.mant / 0x100000000;\n    lowWord = norm.mant >>> 0;\n    writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n  }\n}\n\n;\n(function install() {\n  var exports = typeof module === 'object' && module.exports || this;\n  exports.readWord = readWord;\n  exports.writeWord = writeWord;\n  exports.writeDoubleWord = writeDoubleWord;\n  exports.readFloat = readFloat;\n  exports.writeFloat = writeFloat;\n  exports.readDouble = readDouble;\n  exports.writeDouble = writeDouble; // expose the implementation to the tests\n\n  exports._useFloatArray = function (yesno) {\n    exports._usingFloatArray = yesno;\n\n    if (yesno) {\n      // software conversion is faster for float32 than Float32Array\n      // Only read via Float32Array if yesno == 'full'.\n      if (yesno == 'full') exports.readFloatLE = isBigeCpu ? readFloat32ArrayRev : readFloat32Array;\n      exports.writeFloatLE = isBigeCpu ? writeFloat32ArrayRev : writeFloat32Array;\n      if (yesno == 'full') exports.readFloatBE = isBigeCpu ? readFloat32Array : readFloat32ArrayRev;\n      exports.writeFloatBE = isBigeCpu ? writeFloat32Array : writeFloat32ArrayRev;\n      exports.readDoubleLE = isBigeCpu ? readFloat64ArrayRev : readFloat64Array;\n      exports.writeDoubleLE = isBigeCpu ? writeFloat64ArrayRev : writeFloat64Array;\n      exports.readDoubleBE = isBigeCpu ? readFloat64Array : readFloat64ArrayRev;\n      exports.writeDoubleBE = isBigeCpu ? writeFloat64Array : writeFloat64ArrayRev;\n    } else {\n      exports._usingFloatArray = '';\n\n      exports.readFloatLE = function readFloatLE(buf, offset) {\n        return exports.readFloat(buf, offset || 0, 'le');\n      };\n\n      exports.writeFloatLE = function writeFloatLE(buf, v, offset) {\n        exports.writeFloat(buf, v, offset || 0, 'le');\n      };\n\n      exports.readFloatBE = function readFloatBE(buf, offset) {\n        return exports.readFloat(buf, offset || 0, 'bige');\n      };\n\n      exports.writeFloatBE = function writeFloatBE(buf, v, offset) {\n        exports.writeFloat(buf, v, offset || 0, 'bige');\n      };\n\n      exports.readDoubleLE = function readDoubleLE(buf, offset) {\n        return exports.readDouble(buf, offset || 0, 'le');\n      };\n\n      exports.writeDoubleLE = function writeDoubleLE(buf, v, offset) {\n        exports.writeDouble(buf, v, offset || 0, 'le');\n      };\n\n      exports.readDoubleBE = function readDoubleBE(buf, offset) {\n        return exports.readDouble(buf, offset || 0, 'bige');\n      };\n\n      exports.writeDoubleBE = function writeDoubleLE(buf, v, offset) {\n        exports.writeDouble(buf, v, offset || 0, 'bige');\n      };\n    }\n  }; // expose the cpu endianism to the tests\n\n\n  exports._getBigeCpu = function () {\n    return isBigeCpu;\n  };\n\n  exports._setBigeCpu = function (yesno) {\n    isBigeCpu = yesno;\n  }; // by default export the software conversion functions, then\n  // if available, convert by casting a FloatArray to a byte array\n\n\n  exports._useFloatArray(false);\n\n  exports._useFloatArray(readFloat32Array && readFloat64Array && 'fastest'); // accelerate access\n\n\n  install.prototype = exports;\n}).call(this);","map":{"version":3,"sources":["/Users/kevinbadinger/eos/reactdemo/WCWReact/node_modules/atomicassets/lib/float.js"],"names":["isBigeCpu","readFloat32Array","writeFloat32Array","readFloat32ArrayRev","writeFloat32ArrayRev","readFloat64Array","writeFloat64Array","readFloat64ArrayRev","writeFloat64ArrayRev","Float32Array","_fp32","_b32","Uint8Array","buffer","buf","pos","length","v","Float64Array","_fp64","_b64","readWord","offs","dirn","a","b","c","d","writeWord","writeDoubleWord","hi","lo","_2eXp","Array","i","Math","pow","_2eXn","pow2","exp","_rshift32","_rshift20","_lshift32","_rshift52","_rshift1023","readDouble","offset","w0","w1","highWord","lowWord","mantissa","exponent","sign","value","NaN","Infinity","_rshift23","_rshift127","readFloat","word","_parts","mant","normalize","countDoublings","_2e192","n","roundMantissa","scale","floor","writeFloat","norm","doubleArray","doubleBuf","_2e52","writeDouble","install","exports","module","_useFloatArray","yesno","_usingFloatArray","readFloatLE","writeFloatLE","readFloatBE","writeFloatBE","readDoubleLE","writeDoubleLE","readDoubleBE","writeDoubleBE","_getBigeCpu","_setBigeCpu","prototype","call"],"mappings":"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","sourcesContent":["/**\n * pure javascript functions to read and write 32-bit and 64-bit IEEE 754 floating-point\n *\n * Copyright (C) 2017-2019 Andras Radics\n * Licensed under the Apache License, Version 2.0\n */\n// removed buffer\n\n'use strict';\n\nvar isBigeCpu = false;\nvar readFloat32Array, writeFloat32Array, readFloat32ArrayRev, writeFloat32ArrayRev;\nvar readFloat64Array, writeFloat64Array, readFloat64ArrayRev, writeFloat64ArrayRev;\n\n\n// test FloatArray existence with && to not throw off code coverage\n(typeof Float32Array === 'function') && (function(){\n    var _fp32 = new Float32Array(1);\n    var _b32 = new Uint8Array(_fp32.buffer);\n\n    _fp32[0] = -1;\n    isBigeCpu = _b32[3] === 0;\n\n    readFloat32Array = function readFloat32Array( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 4 > buf.length) return 0;\n        _b32[0] = buf[pos++]; _b32[1] = buf[pos++]; _b32[2] = buf[pos++];_b32[3] = buf[pos];\n        //_b32[0] = buf[pos+0]; _b32[1] = buf[pos+1]; _b32[2] = buf[pos+2]; _b32[3] = buf[pos+3];\n        return _fp32[0];\n    }\n\n    readFloat32ArrayRev = function readFloat32ArrayRev( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 4 > buf.length) return 0;\n        _b32[3] = buf[pos++]; _b32[2] = buf[pos++]; _b32[1] = buf[pos++]; _b32[0] = buf[pos];\n        //_b32[3] = buf[pos+0]; _b32[2] = buf[pos+1]; _b32[1] = buf[pos+2]; _b32[0] = buf[pos+3];\n        return _fp32[0];\n    }\n\n    writeFloat32Array = function writeFloat32Array( buf, v, pos ) {\n        pos = pos || 0;\n        _fp32[0] = v;\n        buf[pos++] = _b32[0]; buf[pos++] = _b32[1]; buf[pos++] = _b32[2]; buf[pos] = _b32[3];\n        //buf[pos+0] = _b32[0]; buf[pos+1] = _b32[1]; buf[pos+2] = _b32[2]; buf[pos+3] = _b32[3];\n    }\n\n    writeFloat32ArrayRev = function writeFloat32ArrayRev( buf, v, pos ) {\n        pos = pos || 0;\n        _fp32[0] = v;\n        buf[pos++] = _b32[3]; buf[pos++] = _b32[2]; buf[pos++] = _b32[1]; buf[pos] = _b32[0];\n        //buf[pos+0] = _b32[3]; buf[pos+1] = _b32[2]; buf[pos+2] = _b32[1]; buf[pos+3] = _b32[0];\n    }\n})();\n\n(typeof Float64Array === 'function') && (function(){\n    var _fp64 = new Float64Array(1);\n    var _b64 = new Uint8Array(_fp64.buffer);\n\n    readFloat64Array = function readFloat64Array( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 8 > buf.length) return 0;\n        //_b64[0] = buf[pos++]; _b64[1] = buf[pos++]; _b64[2] = buf[pos++]; _b64[3] = buf[pos++];\n        //_b64[4] = buf[pos++]; _b64[5] = buf[pos++]; _b64[6] = buf[pos++]; _b64[7] = buf[pos];\n        _b64[0] = buf[pos+0]; _b64[1] = buf[pos+1]; _b64[2] = buf[pos+2]; _b64[3] = buf[pos+3];\n        _b64[4] = buf[pos+4]; _b64[5] = buf[pos+5]; _b64[6] = buf[pos+6]; _b64[7] = buf[pos+7];\n        return _fp64[0];\n    }\n\n    readFloat64ArrayRev = function readFloat64ArrayRev( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 8 > buf.length) return 0;\n        //_b64[7] = buf[pos++]; _b64[6] = buf[pos++]; _b64[5] = buf[pos++]; _b64[4] = buf[pos++];\n        //_b64[3] = buf[pos++]; _b64[2] = buf[pos++]; _b64[1] = buf[pos++]; _b64[0] = buf[pos];\n        _b64[7] = buf[pos+0]; _b64[6] = buf[pos+1]; _b64[5] = buf[pos+2]; _b64[4] = buf[pos+3];\n        _b64[3] = buf[pos+4]; _b64[2] = buf[pos+5]; _b64[1] = buf[pos+6]; _b64[0] = buf[pos+7];\n        return _fp64[0];\n    }\n\n    writeFloat64Array = function writeFloat64Array( buf, v, pos ) {\n        pos = pos || 0;\n        _fp64[0] = v;\n        buf[pos + 0] = _b64[0]; buf[pos + 1] = _b64[1]; buf[pos + 2] = _b64[2]; buf[pos + 3] = _b64[3];\n        buf[pos + 4] = _b64[4]; buf[pos + 5] = _b64[5]; buf[pos + 6] = _b64[6]; buf[pos + 7] = _b64[7];\n    }\n\n    writeFloat64ArrayRev = function writeFloat64ArrayRev( buf, v, pos ) {\n        pos = pos || 0;\n        _fp64[0] = v;\n        buf[pos + 0] = _b64[7]; buf[pos + 1] = _b64[6]; buf[pos + 2] = _b64[5]; buf[pos + 3] = _b64[4];\n        buf[pos + 4] = _b64[3]; buf[pos + 5] = _b64[2]; buf[pos + 6] = _b64[1]; buf[pos + 7] = _b64[0];\n    }\n})();\n\n\n// arithmetic operations preserve NaN, but logical ops (, >>, etc) convert them to zero\n// Assemble the word to generate NaN if any reads are undefined (outside the bounds of the array).\nfunction readWord( buf, offs, dirn ) {\n    var a = buf[offs++], b = buf[offs++], c = buf[offs++], d = buf[offs];\n    return (dirn === 'bige')\n        ? (((((a * 256) + b) * 256) + c) * 256) + d\n        : (((((d * 256) + c) * 256) + b) * 256) + a;\n}\n\nfunction writeWord( buf, v, offs, dirn ) {\n    var a = (v >>> 24) & 0xff, b = (v >> 16) & 0xff, c = (v >> 8) & 0xff, d = (v) & 0xff;\n    (dirn === 'bige')\n        ? (buf[offs++] = a, buf[offs++] = b, buf[offs++] = c, buf[offs] = d)\n        : (buf[offs++] = d, buf[offs++] = c, buf[offs++] = b, buf[offs] = a)\n}\n\n// write the two-word value [hi,lo] where hi holds the 32 msb bits and lo the 32 lsb bits\nfunction writeDoubleWord( buf, hi, lo, offs, dirn ) {\n    if (dirn === 'bige') {\n        writeWord(buf, hi, offs, dirn);\n        writeWord(buf, lo, offs + 4, dirn);\n    }\n    else {\n        writeWord(buf, lo, offs, dirn);\n        writeWord(buf, hi, offs + 4, dirn);\n    }\n}\n\n// given an exponent n, return 2**n\n// n is always an integer, faster to shift when possible\n// Note that nodejs Math.pow() is faster than a lookup table (may be caching)\nvar _2eXp = new Array(); for (var i=0; i<1200; i++) _2eXp[i] = Math.pow(2, i);\nvar _2eXn = new Array(); for (var i=0; i<1200; i++) _2eXn[i] = Math.pow(2, -i);\nfunction pow2( exp ) {\n    return (exp >= 0) ? _2eXp[exp] : _2eXn[-exp];\n    //return (exp >= 0) ? (exp <  31 ? (1 << exp) :        Math.pow(2, exp))\n    //                  : (exp > -31 ? (1 / (1 << -exp)) : Math.pow(2, exp));\n}\n\n\n// getFloat() from qbson, https://github.com/andrasq/node-qbson:\n/*\n * extract the 64-bit little-endian ieee 754 floating-point value\n *   see http://en.wikipedia.org/wiki/Double-precision_floating-point_format\n *   1 bit sign + 11 bits exponent + (1 implicit mantissa 1 bit) + 52 mantissa bits\n */\nvar _rshift32 = (1 / 0x100000000);      // >> 32 for floats\nvar _rshift20 = (1 / 0x100000);         // >> 20 for floats\nvar _lshift32 = (1 * 0x100000000);      // << 32\nvar _rshift52 = (1 * _rshift32 * _rshift20);    // >> 52\nvar _rshift1023 = pow2(-1023);          // 2^-1023\nfunction readDouble( buf, offset, dirn ) {\n    var w0 = readWord(buf, offset, dirn);\n    var w1 = readWord(buf, offset + 4, dirn);\n    var highWord, lowWord;\n    (dirn === 'bige') ? (highWord = w0, lowWord = w1) : (highWord = w1, lowWord = w0);\n\n    var mantissa = (highWord & 0x000FFFFF) * _lshift32 + lowWord;\n    var exponent = (highWord & 0x7FF00000) >>> 20;\n    var sign = (highWord >> 31) || 1;   // -1, 1, or 1 if NaN\n\n    var value;\n    if (exponent === 0x000) {\n        // zero if !mantissa, else subnormal (non-normalized reduced precision small value)\n        // recover negative zero -0.0 as distinct from 0.0\n        // subnormals do not have an implied leading 1 bit and are positioned 1 bit to the left\n        value = mantissa ? (mantissa * pow2(-52 + 1 -1023)) : 0.0;\n    }\n    else if (exponent < 0x7ff) {\n        // normalized value with an implied leading 1 bit and 1023 biased exponent\n        // test for NaN with (mantissa >= 0), and return 0 if NaN ie read from outside buffer bounds\n        value = (mantissa >= 0) ? (1 + mantissa * _rshift52) * pow2(exponent - 1023) : 0.0;\n    }\n    else {\n        // Infinity if zero mantissa (+/- per sign), NaN if nonzero mantissa\n        value = mantissa ? NaN : Infinity;\n    }\n\n    return sign * value;\n}\n\n//\n// Note: node-v9 prefers +28% (sign * value), node v6 doesnt care, node v8 likes +16% (-value : value)\n//\n// float32: 1 sign + 8 exponent + 24 mantissa (23 stored, 1 implied)\n// see https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n//\n// Exponent     Mantissa == 0   Mantissa > 0    Value\n// 00           +0, -0          denormalized    2^(  1-127) * (0. + (mantissa / 2^23))\n// 00.. FE                      normalized      2^(exp-127) * (1. + (mantissa / 2^23))\n// FF           +/-Infinity     NaN             -\n//\nvar _rshift23 = Math.pow(2, -23);      // >> 23 for floats\nvar _rshift127 = Math.pow(2, -127);    // 2^-127\nfunction readFloat( buf, offset, dirn ) {\n    var word = readWord(buf, offset, dirn);\n    var mantissa = (word & 0x007FFFFF);\n    var exponent = (word & 0x7F800000) >>> 23;\n    var sign = (word >> 31) || 1;       // -1, 1, or 1 if NaN\n\n    var value;\n    if (exponent === 0x000) {\n        value = mantissa ? mantissa * _rshift23 * 2 * _rshift127 : 0.0;\n    }\n    else if (exponent < 0xff) {\n        value = (1 + mantissa * _rshift23) * pow2(exponent - 127) // * _rshift127;\n    }\n    else {\n        value = mantissa ? NaN : Infinity;\n    }\n\n    return sign * value;\n    //return (word >>> 31) ? -value : value;\n}\n\n// given a positive value v, normalize it to between 1 and less than 2 with a binary exponent\n// The exponent is the number of bit places it was shifted, positive if v was >= 2.\n// The special values 0, -0, NaN, +Infinity and -Infinity are not handled here.\n// Looping is faster than (Math.log(v) / Math.LN2) in node-v6, v8, and v9.\n// This function can account for half the time taken to write a double.\nvar _parts = { exp: 0, mant: 0 };\nfunction normalize( v ) {\n    var exp = 0;\n\n    if (v >= 2) {\n        exp = countDoublings(1, v);\n        v *= pow2(-exp);\n        // if doubled to exactly v/2, adjust up to v\n        if (v >= 2) { v /= 2; exp += 1 }\n    }\n    else if (v < 1) {\n        exp = countDoublings(v, 2);\n        // avoid using pow2 exponents > 1023, they overflow to Infinity\n        if (exp <= 1023) v *= pow2(exp);\n        else { v *= pow2(exp - 100); v *= pow2(100); }\n        exp = -exp;\n    }\n\n    // TODO: pass in num bits, and normalize straight to mantissa / denorm\n\n    _parts.exp = exp;\n    _parts.mant = v;\n    return _parts;\n}\n\n// count how many doublings of a are needed for it be close to b.\n// Returns a shift count that grows (a) to at least (b/2) but less than (b).\n// Doubling 1 toward v ensures that (v >> n) >= 1 < 2,\n// and doubling from v toward 2 ensures that (v << n) >= 1 < 2.\nvar _2e192 = Math.pow(2, 192);\nfunction countDoublings( a, b ) {\n    var n = 0;\n\n    while (a * _2e192 < b) { a *= _2e192; n += 192 }\n    while (a * 0x10000000000000000 < b) { a *= 0x10000000000000000; n += 64 }\n    while (a * 0x10000 < b) { a *= 0x10000; n += 16 }\n    while (a * 0x40 < b) { a *= 0x40; n += 6 }\n    while (a * 2 < b) { a *= 2; n += 1 }\n\n    return n;\n}\n\n// round the fraction in v and scale up to scale = 2^n bits\n// https://blog.angularindepth.com/how-to-round-binary-fractions-625c8fa3a1af\n// Rounding can cause the scaled value to exceed 2^n.\nfunction roundMantissa( v, scale ) {\n    v *= scale;\n    // round to nearest, but round a 0.5 tie to even (0.5 to 0.0 and 1.5 to 2.0)\n    // round all numbers with a fraction other than 1/2, and round up odd numbers with\n    return ((v - Math.floor(v) !== 0.5) || (v & 1)) ? v + 0.5 : v;\n}\n\n// float32: 1 sign + 8 exponent + (1 implied mantissa 1 bit) + 23 stored mantissa bits\n// NaN types: quiet Nan = x.ff.8xxx, signaling NaN = x.ff.0xx1 (msb zero, at least one other bit set)\n// JavaScript built-in NaN is the non-signaling 7fc00000, but arithmetic can yield a negative NaN ffc00000.\nfunction writeFloat( buf, v, offset, dirn ) {\n    var norm, word, sign = 0;\n    if (v < 0) { sign = 0x80000000; v = -v; }\n\n    if (! (v && v < Infinity)) {\n        if (v === 0) {                  // -0, +0\n            word = (1/v < 0) ? 0x80000000 : 0x00000000;\n        }\n        else if (v === Infinity) {      // -Infinity, +Infinity\n            word = sign | 0x7F800000;\n        }\n        else {                          // NaN - positive, non-signaling\n            word = 0x7FC00000;\n        }\n        writeWord(buf, word, offset, dirn);\n    }\n    else {\n        norm = normalize(v);            // separate exponent and mantissa\n        norm.exp += 127;                // bias exponent\n\n        if (norm.exp <= 0) {            // denormalized number\n            if (norm.exp <= -25) {      // too small, underflow to zero.  -24 might round up though.\n                norm.mant = 0;\n                norm.exp = 0;\n            } else {                    // denormalize\n                norm.mant = roundMantissa(norm.mant, pow2(22 + norm.exp));\n                norm.exp = 0;           // rounding can carry out and re-normalize the number\n                if (norm.mant >= 0x800000) { norm.mant -= 0x800000; norm.exp += 1 }\n            }\n        } else {\n            norm.mant = roundMantissa(norm.mant - 1, 0x800000);\n            // if rounding overflowed into the hidden 1s place, hide it and adjust the exponent\n            if (norm.mant >= 0x800000) { norm.mant -= 0x800000; norm.exp += 1 }\n            if (norm.exp > 254) {       // overflow to Infinity\n                norm.mant = 0;\n                norm.exp = 255;\n            }\n        }\n\n        word = sign | (norm.exp << 23) | norm.mant;\n        writeWord(buf, word, offset, dirn);\n    }\n}\n\n// double64: 1 bit sign + 11 bits exponent + (1 implied mantissa 1 bit) + 52 stored mantissa bits\n// Writing doubles is simpler than floats, because the internal javascript 64-bit floats\n// are identical to the stored representation, and thus will not overflow or underflow.\nvar doubleArray = [0, 0, 0, 0, 0, 0, 0, 0];\nvar doubleBuf = new Uint8Array(8);\nvar _2e52 = Math.pow(2, 52);\nfunction writeDouble( buf, v, offset, dirn ) {\n    var norm, highWord, lowWord, sign = 0;\n    if (v < 0) { sign = 0x80000000; v = -v; }\n\n    if (! (v && v < Infinity)) {\n        if (v === 0) {                  // -0, +0\n            highWord = (1/v < 0) ? 0x80000000 : 0;\n            lowWord = 0;\n        }\n        else if (v === Infinity) {      // -Infinity, +Infinity\n            highWord = (sign + 0x7FF00000);\n            lowWord = 0;\n        }\n        else {                          // NaN - positive, non-signaling\n            highWord = 0x7FF80000;\n            lowWord = 0;\n        }\n        writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n    }\n    else {\n        norm = normalize(v);            // separate exponent and mantissa\n        norm.exp += 1023;               // bias exponent\n\n        if (norm.exp <= 0) {            // denormalized\n            // JavaScript numbers can not hold values small enough to underflow\n            // and no need to round, all bits will be written\n            norm.mant *= pow2(51 + norm.exp);\n            norm.exp = 0;\n        }\n        else {\n            // no need to round, all bits will be written\n            norm.mant = (norm.mant - 1) * _2e52;\n        }\n\n        highWord = sign | (norm.exp << 20) | (norm.mant / 0x100000000);\n        lowWord = norm.mant >>> 0;\n        writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n    }\n}\n\n\n;(function install() {\n    var exports = typeof module === 'object' && module.exports || this;\n\n    exports.readWord = readWord;\n    exports.writeWord = writeWord;\n    exports.writeDoubleWord = writeDoubleWord;\n\n    exports.readFloat = readFloat;\n    exports.writeFloat = writeFloat;\n    exports.readDouble = readDouble;\n    exports.writeDouble = writeDouble;\n\n    // expose the implementation to the tests\n    exports._useFloatArray = function( yesno ) {\n        exports._usingFloatArray = yesno;\n        if (yesno) {\n            // software conversion is faster for float32 than Float32Array\n            // Only read via Float32Array if yesno == 'full'.\n            if (yesno == 'full') exports.readFloatLE = isBigeCpu ? readFloat32ArrayRev : readFloat32Array;\n            exports.writeFloatLE = isBigeCpu ? writeFloat32ArrayRev : writeFloat32Array;\n            if (yesno == 'full') exports.readFloatBE = isBigeCpu ? readFloat32Array : readFloat32ArrayRev;\n            exports.writeFloatBE = isBigeCpu ? writeFloat32Array : writeFloat32ArrayRev;\n\n            exports.readDoubleLE = isBigeCpu ? readFloat64ArrayRev : readFloat64Array;\n            exports.writeDoubleLE = isBigeCpu ? writeFloat64ArrayRev : writeFloat64Array;\n            exports.readDoubleBE = isBigeCpu ? readFloat64Array : readFloat64ArrayRev;\n            exports.writeDoubleBE = isBigeCpu ? writeFloat64Array : writeFloat64ArrayRev;\n        }\n        else {\n            exports._usingFloatArray = '';\n            exports.readFloatLE = function readFloatLE( buf, offset ) { return exports.readFloat(buf, offset || 0, 'le'); }\n            exports.writeFloatLE = function writeFloatLE( buf, v, offset ) { exports.writeFloat(buf, v, offset || 0, 'le'); };\n            exports.readFloatBE = function readFloatBE( buf, offset ) { return exports.readFloat(buf, offset || 0, 'bige'); }\n            exports.writeFloatBE = function writeFloatBE( buf, v, offset ) { exports.writeFloat(buf, v, offset || 0, 'bige'); }\n\n            exports.readDoubleLE = function readDoubleLE( buf, offset ) { return exports.readDouble(buf, offset || 0, 'le'); }\n            exports.writeDoubleLE = function writeDoubleLE( buf, v, offset ) { exports.writeDouble(buf, v, offset || 0, 'le'); }\n            exports.readDoubleBE = function readDoubleBE( buf, offset ) { return exports.readDouble(buf, offset || 0, 'bige'); }\n            exports.writeDoubleBE = function writeDoubleLE( buf, v, offset ) { exports.writeDouble(buf, v, offset || 0, 'bige'); }\n        }\n    }\n\n    // expose the cpu endianism to the tests\n    exports._getBigeCpu = function() { return isBigeCpu };\n    exports._setBigeCpu = function(yesno) { isBigeCpu = yesno };\n\n    // by default export the software conversion functions, then\n    // if available, convert by casting a FloatArray to a byte array\n    exports._useFloatArray(false);\n    exports._useFloatArray(readFloat32Array && readFloat64Array && 'fastest');\n\n    // accelerate access\n    install.prototype = exports;\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}